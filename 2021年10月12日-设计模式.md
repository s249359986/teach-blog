# 设计模式
## 设计模式目的
设计模式是为了更好的代码重用性，可读性，可靠性，可维护性。

## 设计六大原则

1. 单一职责原则
2. 里氏替换原则
3. 依赖倒转原则
4. 接口隔离原则
5. 最少知识原则(迪米特法则)
6. 开放封闭原则


## 设计模式分类
### 总体来说设计模式分为三大类：

创建型模式，共五种：工厂方法模式、抽象工厂模式、单例模式、建造者模式、原型模式。

1、工厂模式


## 面向对象编程
1.面向对象分析和面向对象设计？

### 特征
1.封装

2.抽象

3.继承

4.多态



### 设计原则

1.“基于接口而非实现编程”，这条原则的另一个表述方式，是“基于抽象而非实现编程”。后者的表述方式其实更能体现这条原则的设计初衷。我们在做软件开发的时候，一定要有抽象意识、封装意识、接口意识。越抽象、越顶层、越脱离具体某一实现的设计，越能提高代码的灵活性、扩展性、可维护性。

2.我们在定义接口的时候，一方面，命名要足够通用，不能包含跟具体实现相关的字眼；另一方面，与特定实现有关的方法不要定义在接口中。

3.“基于接口而非实现编程”这条原则，不仅仅可以指导非常细节的编程开发，还能指导更加上层的架构设计、系统设计等。比如，服务端与客户端之间的“接口”设计、类库的“接口”设计。

1.为什么不推荐使用继承？

继承是面向对象的四大特性之一，用来表示类之间的is-a关系，可以解决代码复用的问题。虽然继承有诸多作用，但继承层次过深、过复杂，也会影响到代码的可维护性。在这种情况下，我们应该尽量少用，甚至不用继承。

2.组合相比继承有哪些优势？

继承主要有三个作用：表示is-a关系，支持多态特性，代码复用。而这三个作用都可以通过组合、接口、委托三个技术手段来达成。除此之外，利用组合还能解决层次过深、过复杂的继承关系影响代码可维护性的问题。
- 组合便于横向扩展

3.如何判断该用组合还是继承？

尽管我们鼓励多用组合少用继承，但组合也并不是完美的，继承也并非一无是处。在实际的项目开发中，我们还是要根据具体的情况，来选择该用继承还是组合。如果类之间的继承结构稳定，层次比较浅，关系不复杂，我们就可以大胆地使用继承。反之，我们就尽量使用组合来替代继承。除此之外，还有一些设计模式、特殊的应用场景，会固定使用继承或者组合。

#### 控制反转，依赖反转，依赖注入
1.控制反转
控制反转是一个比较笼统的设计思想，并不是一种具体的实现方法，一般用来知道框架层面的设计。“控制”指的是对程序执行流程的控制，而“反转”指的是在没有使用框架之前，程序员自己控制整个程序的执行。在使用框架之后，整个程序的执行流程通过框架来控制。流程控制权从程序员“反转”给了框架。


2.依赖注入
- 依赖植入和控制反转恰恰相反，它是一种具体的编码技巧。
- 不通过 new() 的方式在类内部创建依赖类对象，而是将依赖的对象在外部创建好之后，通过构造函数，函数参数等方式给类使用。
```
// 非依赖注入
class Feeder {
constructor() { 
 this.animal = new Dog()
}
 feed(food) {
  this.animal.eat(food)
 }
}

class Dog {
  eat(food) {
   console.log("food",food)
  }

}

let feeder = new Feeder()
feeder.feed("骨头")


// 使用依赖注入

class Feeder {
constructor(animal) { 
 this.animal = animal
}
 feed(food) {
  this.animal.eat(food)
 }
}

class Dog {
  eat(food) {
   console.log("food",food)
  }

}

let dog = new Dog()
let feeder = new Feeder(dog)
feeder.feed("骨头");


```
通过依赖注入提高代码的扩展性，灵活替代依赖的类

3.依赖反转原则
依赖反转原则也叫做依赖倒置原则，这条原则跟控制反转有点类似，主要用来知道框架层面的设计。高层模块不依赖底层模块，它们共同依赖一个抽象。抽象不要依赖具体实现细节，具体实现细节依赖抽象。

## 参考资料

https://www.yuque.com/u21687997/dxgwen/tx6d22

