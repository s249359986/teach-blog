# 设计模式
## 设计模式目的
设计模式是为了更好的代码重用性，可读性，可靠性，可维护性。

## 设计六大原则

1. 单一职责原则
### 里氏替换原则

- 指导继承关系中子类该如何设计的一个原则，理解里氏替换原则，最核心的就是理解 design by contract, 按照协议来设计。父类定义函数的约定，那子类可以改变函数的内部实现逻辑，但不能改变函数原有的“约定”。约定包括：函数声明要实现的功能；对输入，输出，异常的约定；甚至包括注释中所罗列的任何特殊说明。
- 里氏替换和多态的区别。虽然从定义描述和代码实现上看，多态和里氏替换类似，但他们关注的角度不一样，多态是面向对象编程的一大特性，也是面向对象编程语言的一种语法。它是一种代码实现的思路。而里氏替换是一种设计原则。

4. 依赖倒转原则
### 接口隔离原则

1.接口隔离原则的重点是理解其中的“接口”二字。这里有三种不同的理解。
- 一组接口集合，可以是某个微服务的接口，也可以是某个类库的接口等。如果部分接口只被部分调用者使用，我们就需要将这部分接口隔离出来，单独给这部分调用者使用，而不是强迫其他调用者也依赖这部分不会被用到的接口。
- 单个api或函数，部分调用者只需要函数中的部分功能，那我们就需要把函数拆分成颗粒度更细的多个函数，让调用者只依赖它需要的那个函数。
- oop中的接口，也可以理解为面向对象编程语言中的接口语法，不要让接口实现类和调用者，依赖不需要的接口函数。

2.接口隔离原则与单一原则的区别
单一职责针对的是模块，类，接口的设计。接口隔离原则相对于单一职责原则一方面更侧重于接口的设计，另一方面它的思考角度也是不同。接口隔离原则提供一种判断接口的职责是否单一的标准；


### 最小知识原则(迪米特法则)
每个模块只应该了解哪些与它关系密切的模块的有限知识



7. 开放封闭原则


## 设计模式分类
### 总体来说设计模式分为三大类：

创建型模式，共五种：工厂方法模式、抽象工厂模式、单例模式、建造者模式、原型模式。

1、工厂模式


## 面向对象编程
1.面向对象分析和面向对象设计？

### 特征
1.封装

2.抽象

3.继承

4.多态



### 设计原则

1.“基于接口而非实现编程”，这条原则的另一个表述方式，是“基于抽象而非实现编程”。后者的表述方式其实更能体现这条原则的设计初衷。我们在做软件开发的时候，一定要有抽象意识、封装意识、接口意识。越抽象、越顶层、越脱离具体某一实现的设计，越能提高代码的灵活性、扩展性、可维护性。

2.我们在定义接口的时候，一方面，命名要足够通用，不能包含跟具体实现相关的字眼；另一方面，与特定实现有关的方法不要定义在接口中。

3.“基于接口而非实现编程”这条原则，不仅仅可以指导非常细节的编程开发，还能指导更加上层的架构设计、系统设计等。比如，服务端与客户端之间的“接口”设计、类库的“接口”设计。

1.为什么不推荐使用继承？

继承是面向对象的四大特性之一，用来表示类之间的is-a关系，可以解决代码复用的问题。虽然继承有诸多作用，但继承层次过深、过复杂，也会影响到代码的可维护性。在这种情况下，我们应该尽量少用，甚至不用继承。

2.组合相比继承有哪些优势？

继承主要有三个作用：表示is-a关系，支持多态特性，代码复用。而这三个作用都可以通过组合、接口、委托三个技术手段来达成。除此之外，利用组合还能解决层次过深、过复杂的继承关系影响代码可维护性的问题。
- 组合便于横向扩展

3.如何判断该用组合还是继承？

尽管我们鼓励多用组合少用继承，但组合也并不是完美的，继承也并非一无是处。在实际的项目开发中，我们还是要根据具体的情况，来选择该用继承还是组合。如果类之间的继承结构稳定，层次比较浅，关系不复杂，我们就可以大胆地使用继承。反之，我们就尽量使用组合来替代继承。除此之外，还有一些设计模式、特殊的应用场景，会固定使用继承或者组合。

4.高内聚
相近功能放到同一类，不相近的功能不要放到同一类中。相近的功能往往会被同时修改，放到同一个类中，修改会比较集中，代码容易维护。我们前面讲过的单一职责原则是实现代码高内聚非常有效的设计原则。

5.松耦合
类与类之间的依赖关系简单清晰。即使两个类有依赖关系，一个类的代码改动不会或者很少导致依赖类的代码改动。

#### 解构

发现

1.通过画关系图判断耦合性。

如何

1.封装和抽象

2.中间层



尽管我们鼓励多用组合少用继承，但组合也并不是完美的，继承也并非一无是处。在实际的项目开发中，我们还是要根据具体的情况，来选择该用继承还是组合。如果类之间的继承结构稳定，层次比较浅，关系不复杂，我们就可以大胆地使用继承。反之，我们就尽量使用组合来替代继承。除此之外，还有一些设计模式、特殊的应用场景，会固定使用继承或者组合。

#### 控制反转，依赖反转，依赖注入
1.控制反转
控制反转是一个比较笼统的设计思想，并不是一种具体的实现方法，一般用来知道框架层面的设计。“控制”指的是对程序执行流程的控制，而“反转”指的是在没有使用框架之前，程序员自己控制整个程序的执行。在使用框架之后，整个程序的执行流程通过框架来控制。流程控制权从程序员“反转”给了框架。


2.依赖注入
- 依赖植入和控制反转恰恰相反，它是一种具体的编码技巧。
- 不通过 new() 的方式在类内部创建依赖类对象，而是将依赖的对象在外部创建好之后，通过构造函数，函数参数等方式给类使用。
```
// 非依赖注入
class Feeder {
constructor() { 
 this.animal = new Dog()
}
 feed(food) {
  this.animal.eat(food)
 }
}

class Dog {
  eat(food) {
   console.log("food",food)
  }

}

let feeder = new Feeder()
feeder.feed("骨头")


// 使用依赖注入

class Feeder {
constructor(animal) { 
 this.animal = animal
}
 feed(food) {
  this.animal.eat(food)
 }
}

class Dog {
  eat(food) {
   console.log("food",food)
  }

}

let dog = new Dog()
let feeder = new Feeder(dog)
feeder.feed("骨头");


```
通过依赖注入提高代码的扩展性，灵活替代依赖的类

3.依赖反转原则
依赖反转原则也叫做依赖倒置原则，这条原则跟控制反转有点类似，主要用来知道框架层面的设计。高层模块不依赖底层模块，它们共同依赖一个抽象。抽象不要依赖具体实现细节，具体实现细节依赖抽象。

### 规范与重构

1.重构

定义：不改变软件外部的可见行为，使其更易理解，修改成本更低。（在保持功能不变的提前下，利用设计思想，原则，模式，编程规范等理论来优化代码，修改设计的不足，提高代码质量。）

目的

时机：持续重构，主动重构，在平时修代码时发现不合理的地方直接重构。

如何：大规模，需要由经验，熟悉业务的资深同事主导。而小规模低层次的重构，因为影响范围小，改动耗费时间段，所以，只要你愿意并且有时间，随时都可以去做。

2.如何保证重构安全
3.不同规模重构

## 参考资料

https://www.yuque.com/u21687997/dxgwen/tx6d22

